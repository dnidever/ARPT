;+
;
; CCDPROC
;
; This is a generic CCD image processing program.
;
; INPUTS:
;  input       The input list of images.
;  =xtalk
;  =lincorr    Apply linearity correction
;  =fixpix
;  /trim
;  /overscan
;  /gaincorr
;  =zero
;  =flat
;  =illum      Apply
;  =bootstrap  Apply bootstrap correction.
;  =bpm        Apply bad pixel mask using 
;  /clobber
;  /verbose
;  /silent     Don't print anything to the screen.
; 
; OUTPUTS:
;  =error      Error if one occured.
;
; USAGE:
;  IDL>
;
; By D.Nidever  Jan 2014,  based in part on IRAF's ccdproc program
;-

pro ccdproc,input,fixpix=fixpix,trim=trim,overscan=overscan,gaincorr=gaincorr,zero=zero,$
                flat=flat,xtalk=xtalk,illum=illum,bootstrap=bootstrap,bpm=bpm,clobber=clobber,verbose=verbose,$
                lincorr=lincorr,silent=silent,error=error


;====================
; CHECK THE INPUTS
;====================

; Not enough inputs
if n_elements(input) eq 0 then begin
  print,'Syntax - ccdproc,files,editgain=editgain,fixpix=fixpix,xtalk=xtalk,trim=trim,overscan=overscan,'
  print,'                 zero=zero,flat=flat,illum=illum,bootstrap=bootstrap,bpm=bpm,'
  print,'                 lincorr=lincorr,clobber=clobber,verbose=verbose,silent=silent,error=error'
  return
endif

; Load the input files
LOADINPUT,input,files,count=nfiles
files = strtrim(files,2)
if nfiles eq 0 then begin
  print,'No files to process'
  return
endif

; No processing steps requested
if not keyword_set(fixpix) and n_elements(xtalk) eq 0 and not keyword_set(trim) and not keyword_set(overscan) and $
   n_elements(zero) eq 0 and and n_elements(flat) eq 0 and n_elements(illum) eq 0 then begin
  print,'NO PROCESSING STEPS'
  return
endif

; Overscan requested but no TRIM
if keyword_set(overscan) and not keyword_set(trim) then begin
  print,'/OVERSCAN with no TRIMMING not supported'
  return
endif

; Get file information
;   this also works if there is no input or the file doesn't exist
xtalk_info = CCDPROC_FILEINFO(xtalk)
lincorr_info = CCDPROC_FILEINFO(lincorr)
fixpix_info = CCDPROC_FILEINFO(fixpix)
zero_info = CCDPROC_FILEINFO(zero)
flat_info = CCDPROC_FILEINFO(flat)
illum_info = CCDPROC_FILEINFO(illum)
bootstrap_info = CCDPROC_FILEINFO(bootstrap)
bpm_info = CCDPROC_FILEINFO(bpm)

; Check that files exist if input
if n_elements(xtalk) gt 0 and xtalk_info.exists eq 0 then error='XTALK file '+xtalk_info.file+' NOT FOUND'
if n_elements(lincorr) gt 0 and lincorr_info.exists eq 0 then error='LINCORR file '+lincorr_info.file+' NOT FOUND'
if n_elements(fixpix) gt 0 and fixpix_info.exists eq 0 then error='FIXPIX file '+fixpix_info.file+' NOT FOUND'
if n_elements(zero) gt 0 and zero_info.exists eq 0 then error='ZERO file '+zero_info.file+' NOT FOUND'
if n_elements(flat) gt 0 and flat_info.exists eq 0 then error='FLAT file '+flat_info.file+' NOT FOUND'
if n_elements(illum) gt 0 and illum_info.exists eq 0 then error='ILLUM file '+illum_info.file+' NOT FOUND'
if n_elements(bootstrap) gt 0 and bootstrap_info.exists eq 0 then error='Bootstrap file '+bootstrap_info.file+' NOT FOUND'
if n_elements(bpm) gt 0 and bpm_info.exists eq 0 then error='BPM file '+bpm_info.file+' NOT FOUND'
if n_elements(error) gt 0 then begin
  if not keyword_set(silent) then print,error
  return
endif

; Some defaults
if n_elements(zero) eq 0 then zero=''
if n_elements(flat) eq 0 then flat=''
if n_elements(illum) eq 0 then illum=''


;=========================================
; LOAD CALIBRATION DATA USED BY ALL FILES
;=========================================

; Load bootstrap file
if n_elements(bootstrap) gt 0 then begin
  READCOL,bootstrap,ccdnum,amp,scale,format='I,I,F',/silent
  bootstr = replicate({ccdnum:0L,amp:0,scale:0.0},n_elements(ccdnum))
  bootstr.ccdnum = ccdnum
  bootstr.amp = amp
  bootstr.scale = scale
endif

; Load xtalk values
if n_elements(xtalk) gt 0 then begin
  READCOL,xtalk,victim,source,scale,scale_error,format='A,A,F,F',comment='#',/silent
  xstr = replicate({victim:'',victim_chip:0L,victim_amp:'',source:'',$
                    source_chip:0L,source_amp:'',scale:0.0,scale_error:0.0},n_elements(victim))
  xstr.victim = victim
  xstr.source = source
  xstr.scale = scale
  xstr.scale_error = scale_error
  vlen = strlen(xstr.victim)
  slen = strlen(xstr.source)
  for i=0,n_elements(xstr)-1 do xstr[i].victim_chip=long(strmid(xstr[i].victim,0,vlen[i]-1))
  for i=0,n_elements(xstr)-1 do xstr[i].victim_amp=strmid(xstr[i].victim,vlen[i]-1,1)
  for i=0,n_elements(xstr)-1 do xstr[i].source_chip=long(strmid(xstr[i].source,0,slen[i]-1))
  for i=0,n_elements(xstr)-1 do xstr[i].source_amp=strmid(xstr[i].source,slen[i]-1,1)
endif

; Load fixpix file
if n_elements(fixpix) gt 0 then begin
  READLINE,fixpix,fixlines
  ; put this in a fixstr structure
endif


; Print out processing steps
if not keyword_set(silent) begin
  then print,'Processing steps:'
  if n_elements(xtalk) gt 0 then print,'XTALK ',xtalk
  if n_elements(lincorr) gt 0 then print,'LINCORR ',lincorr
  if n_elements(fixpix) gt 0 then print,'FIXPIX ',fixpix
  if keyword_set(trim) then print,'TRIM'
  if keyword_set(overscan) then print,'OVERSCAN'
  if zero ne '' then print,'ZERO ',zero
  if flat ne '' then print,'FLAT ',flat
  if illum ne '' then print,'ILLUM ',illum
  if n_elements(bootstrap) gt 0 then print,'BOOTSTRAP ',bootstrap
  if n_elements(bpm) gt 0 then print,'BPM ',bpm
endif


;=================
; PROCESS FILES
;=================

; Loop over input files
error = strarr(nfiles)
FOR f=0L,nfiles-1 do begin

  ; File information and headers
  info = CCDPROC_FILEINFO(files[f])
  origfile = info.file
  outfile = info.dir+'/'+info.base+'_temp.fits'

  ; File does not exist
  if info.exists eq 0 then begin
    error[f] = origfile+' NOT FOUND'
    if not keyword_set(silent) then print,error[f]
    goto,BOMBFILE
  endif
  ; Not a FITS file
  if info.ext ne 'fits' then begin
    error[f] = origfile+' NOT A FITS FILE'
    if not keyword_set(silent) then print,error[f]
    goto,BOMBFILE
  endif

  if not keyword_set(silent) then print,'Processing ',info.base+'.fits'

  ; !!!!!NEED TO FIGURE OUT HOW TO DO THIS PROPERLY!!!!!
  ;filter = strtrim(sxpar(head0,'FILTER'),2)
  ;dum = strtrim(strsplitter(filter,' ' ,/extract),2)
  ;sfilter = dum[0]
  ;if flat ne '' then begin
  ;  flatfile=flat+'_'+sfilter+'.fits'
  ;  if file_test(flatfile) eq 0 then begin
  ;    print,'FLAT file ',flatfile,' NOT FOUND'
  ;    return
  ;  endif
  ;endif
  ;if illum ne '' then begin
  ;  illumfile=illum+'_'+sfilter+'.fits'
  ;  if file_test(illumfile) eq 0 then begin
  ;    print,'ILLUM file ',illumfile,' NOT FOUND'
  ;    return
  ;  endif
  ;endif


  ; Start output file
  FILE_DELETE,outfile,/allow_nonexistent,/quiet
  if next gt 1 then FITS_WRITE,outfile,0,*(info.hdu[0].head),/no_abort  ; for multi-extension

  ;---------------------------
  ; LOOP OVER THE EXTENSIONS
  ;---------------------------
  if next eq 0 then begin
    loext = 0L
    no_pdu = 0
  endif else begin
    loext = 1L
    no_pdu = 1
  endelse
  FOR i=loext,loext+next-1 do begin

    ; Load the file
    FITS_READ,file,im,head,exten=i,no_pdu=no_pdu,/no_abort,message=message
    if message ne '' then begin
      print,message
      error[f] = message
      FILE_DELETE,outfile,/allow_nonexistent,/quiet  ; delete temporary file
      goto,BOMBFILE
    endif
    origim = im
    im = float(im)

    ;str = {im:im,head:head,fixpix:keyword_set(fixpix),overtimr:keyword_set(overtrim),$
    ;       zero:'',flat:''}

    ; Current timestamp information
    ;Sun Oct  7 15:38:23 2012
    date = systime(0)
    datearr = strtrim(strsplit(date,' ',/extract),2)
    timarr = strsplit(datearr[3],':',/extract)
    datestr = datearr[1]+' '+datearr[2]+' '+strjoin(timarr[0:1],':')

    ;-------
    ; XTALK
    ;=======
    if n_elements(xtalk) gt 0 then begin
       sxaddpar,head,'XTALKCOR',datestr+' XTALK file is '+xtalk
       CCDPROC_XTALK,im,head,i,xstr,verbose=verbose
    endif

    ; SHOULD LINEARITY CORRECTION GO BEFORE XTALK-CORRECTION????

    ;-----------------------
    ; Linearity Correction
    ;=======================
    if n_elements(lincorr) gt 0 then begin
      CCDPROC_LINCORR,im,head
    endif

    ;----------
    ; Fixpix
    ;==========
    if n_elements(fixpix) gt 0 then begin
      CCDPROC_FIXPIX,im,head,fixstr
    endif

    ;--------------
    ; Overscan/trim
    ;==============
    if keyword_set(trim) then begin
      CCDPROC_OVERTRIM,im,head,overscan=overscan,error=error_overtrim,silent=silent
      if n_elements(error_overtrim) gt 0 then return
    endif

    ;-------------
    ; Zero Correct
    ;=============
    if zero ne '' then begin
      FITS_READ,zero,zeroim,zerohead,exten=i,/no_abort
      im -= round(zeroim)  ; im is LONG, zeroim is FLOAT
      sxaddpar,head,'ZEROCOR',datestr+' Zero is '+zero
    endif

    ;-----------------
    ; Domeflat Correct
    ;=================
    if flat ne '' then begin
      head0 = headfits(flatfile,exten=0)
      ccdmean = sxpar(head0,'CCDMEAN',count=nccdmean)
      if nccdmean eq 0 then ccdmean=1
      FITS_READ,flatfile,flatim,flathead,exten=i
      bdpix = where(flatim lt 0.01,nbdpix)  ; fix bad pixels in flat image
      if nbdpix gt 0 then flatim[bdpix]=median(flatim)
      im /= flatim/ccdmean  ; divide chip flat image by the flat field mean
      sxaddpar,head,'FLATCOR',datestr+' Flat is '+flatfile+', scale '+strtrim(string(ccdmean,format='(F20.2)'),2)
    endif

    ;-------------------------
    ; Illumination Correction
    ;=========================
    ; maybe this should be called sflatcor
    if illum ne '' then begin
      head0 = headfits(illumfile,exten=0)
      ccdmean = sxpar(head0,'CCDMEAN',count=nccdmean)
      if nccdmean eq 0 then ccdmean=1
      FITS_READ,illumfile,illumim,illumhead,exten=i
      bdpix = where(illumim lt 0.01,nbdpix)  ; fix bad pixels in illum image
      if nbdpix gt 0 then illumim[bdpix]=median(illumim)
      im /= illumim/ccdmean  ; divide chip illum image by the illum field mean
      sxaddpar,head,'ILLUMCOR',datestr+' ILLUM is '+illumfile+', scale '+strtrim(string(ccdmean,format='(F20.2)'),2)
    endif

    ;---------------
    ; Bootstrap
    ;==============
    if n_elements(bootstrap) gt 0 then begin
      ccdnum = sxpar(head,'CCDNUM')
      bind1 = where(bootstr.ccdnum eq ccdnum and bootstr.amp eq 1,nbind1)
      bind2 = where(bootstr.ccdnum eq ccdnum and bootstr.amp eq 2,nbind2)
      scl1 = bootstr[bind1[0]].scale
      scl2 = bootstr[bind2[0]].scale

      sz = size(im)
      im1 = im[0:sz[1]/2-1,*]
      im2 = im[sz[1]/2:*,*]

      im = [im1*scl1,im2*scl1]

      sxaddpar,head,'BTSTRP',bootstrap
    endif

    ;----------------
    ; Bad Pixel Mask
    ;================
    ; This "saturates" the pixels
    if n_elements(bpm) gt 0 then begin
      FITS_READ,bpm,bpmim,bpmhead,exten=i
      im = im*(bpmim eq 0) + bpmim*65535L
      sxaddpar,head,'BPM',bpm
    endif

    ; Example of how the header is modified.
    ;XTALKCOR= 'Oct  8 21:19 No crosstalk correction required'                       
    ;OVSNMEAN=             1503.989                                                  
    ;TRIM    = 'Oct  8 21:19 Trim is [25:1048,1:4096]'                               
    ;FIXPIX  = 'Oct  8 21:19 Fix mscdb$noao/Mosaic2/CAL0102/bpm3_0102 + sat + bleed' 
    ;OVERSCAN= 'Oct  8 21:19 Overscan is [1063:1112,1:4096], mean 1503.989'          
    ;ZEROCOR = 'Oct  8 21:19 Zero is Zero[im5]'                                      
    ;FLATCOR = 'Oct  8 21:19 Flat is DFlatM.fits[im5], scale 10490.72'               
    ;CCDPROC = 'Oct 18 11:34 CCD processing done'                                    
    ;PROCID  = 'ct4m.20070817T081040V3'                                              
    ;SFLATCOR= 'Oct 18 11:34 Sky flat is Sflatn12M.fits[im5], scale 833.0756'        

    sxaddpar,head,'CCDPROC',datestr+' CCD processing done'

    ; Write output
    MWRFITS,im,outfile,head,/silent

    ;stop

  ENDFOR  ; extension loop

  ; THE PROCESSING STEPS SHOULD GO IN THE PRIMARY HEADER!!!

  ; Move temporary file to original file
  if not keyword_set(clobber) then $
    FILE_MOVE,outfile,file,/overwrite,/allow

  BOMBFILE:

ENDFOR  ; file loop

;stop

end
