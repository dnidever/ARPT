pro ccdproc_lincorr,im,head

; Low-count DECam Linearity correction

ccdnum = sxpar(head,'ccdnum')

;exten  =  6, 15, 17, 19, 20, 24, 25, 44, ~46, ~61
;ccdnum = 34, 45, 51, 21, 22, 18, 15, 31,  42,  61

; These numbers were derived in dcm_fix_linearity.pro
lc_ccdnum = [ 12,  15,  18,  21,  22,   31,  33,  34,  42,  45,  51,  56]
lc_amp    = ['B', 'A', 'B', 'B', 'A',  'A', 'B', 'A', 'B', 'B', 'B', 'A']
lc_value  = [0.8, 7.4, 3.8, 2.1, 1.2, 18.1, 0.7, 2.4, 1.3, 4.5, 1.0, 2.2]
;lc_value  = [0.8, 5.8, 3.8, 2.2, 1.7, 12.0, 2.7, 1.5, 4.4, 1.9, 2.8]

ind = where(lc_ccdnum eq ccdnum,ncorr)

if ncorr gt 0 then begin

  ; Get the right AMP
  amp = lc_amp[ind[0]]
  value = lc_value[ind[0]]

  ; Trimmed or raw image
  trim = sxpar(head,'TRIM',count=ntrim)
  if ntrim gt 0 then sec=dcm_splitsec(sxpar(head,'CCDSEC'+amp))-1 else $
    sec=dcm_splitsec(sxpar(head,'DATASEC'+amp))-1

  ; Original amp image
  Dim = im[sec[0]:sec[1],sec[2]:sec[3]]

  ; Correct the values
  ;  D = detected, T = true value, C = constant
  ;   D/T = T/(T+C)
  ;     D*(T+C) = T^2, T^2-DT-DC=0
  ;   T = (-b+/-sqrt(b^2-4ac))/2a
  ;   T = (D+/-sqrt(D^2+4DC))/2
  ; the second term will always be larger than D so
  ; if we pick the minus sign it will give us negative counts
  ; which is not right.  So we pick the plus sign.
  ;   T = (D+sqrt(D^2+4DC))/2
  ;  need double otherwise D^2 gets too big
  ;  >0 ensures that the correction is zero for negative numbers
  Tim = float( (Dim+sqrt(double(Dim)^2+(4*Dim*value>0)))/2.0 )
  ; should I round to nearest integers??

  ; Plug it back in
  im[sec[0]:sec[1],sec[2]:sec[3]] = Tim

  ; Update header
  sxaddpar,head,'LINCORR',value,' linearity correction'
  sxaddhist,'',head

endif else sxaddpar,head,'LINCORR',0.0,' no linearity correction'

;stop

end 
